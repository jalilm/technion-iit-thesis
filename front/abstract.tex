% This file contains the abstract part of your thesis - in English and
% in Hebrew (within \abstractEnglish and \abstractHebrew respectively).
%
% Notes:
% - This file uses the UTF-8 character set encoding for the Hebrew
%   text not to get garbled. Keep it that way.
% - Assuming your thesis is mainly in English, Graduate School 
%   regulations mandate the following lengths for the abstracts:
%
%      Language    Min. Length   Max. Length
%     ---------------------------------------
%      English       200 words     500 words
%      Hebrew      1,000 words   2,000 words
%
%   so that the Hebrew abstract typically has some content from
%   the English introduction and an overview of the results, not
%   present in the English; it is not just a translation.

\abstractEnglish{

Monitoring network traffic is an important building block for various management and security systems. In typical settings, the number of active flows in a network node is much larger than the number of available monitoring resources and there is no practical way to maintain a “per-flow” state at the node. This situation gave rise to the recent interest in streaming algorithms where complex data structures are used to perform monitoring tasks efficiently. However, these solutions often require either a complicated “per-packet” operation, which is not feasible in current hardware or software network, or an amortized $O(1)$ operation that does not cope with line rate. In this dissertation, we tackle three monitoring tasks that were studied previously and we present for them practical, efficient resource-constrained algorithms.

The first task is identifying the top-$k$ flows flowing through a network node. We presented a different approach to this problem than previous work and studied the ability to perform monitoring tasks using efficient built-in counters available in current network devices. We show that by applying non-trivial control algorithms that change the filter assignments of these built-in counters at a fixed time interval, regardless of packet arrival rate, we can get accurate monitoring information. We provide an analytical study of the top-$k$ flows problem and show, using extensive emulation over recent real traffic, that our algorithm can perform at least as well as the best-known streaming algorithms without using complex data structure or performing expensive “per-packet” operations.

The second task is the hierarchical heavy hitters (HHH) problem, where one needs to identify the most frequent network IP-prefixes hierarchically. For this task, we followed the approach of detecting the top-$k$ flows and proposed a constant-time algorithm for detecting the HHH that does not have any convergence requirements and achieves comparable results to state of the art.
Most importantly, our algorithm uses only efficient built-in counters available in current network devices, making it deployable on commercially off-the-shelf network gear.
We provided an analytical study of the problem and showed, using emulation over real traffic, that our algorithm performs at least as well as the best-known streaming algorithms without performing expensive per-packet operations or requiring convergence periods.

The last task we tackled is the detection of Heavy Hitter (HH) flows in a network device. In this task, a flow is considered a Heavy Hitter flow if its portion from the total traffic surpasses a given threshold. For this task, we present a practical heavy hitters detection algorithm that requires a constant amount of memory (not related to the number of flows or the number of packets) and performs at most $O(1)$ operation per packet to keep with line rate speed. We present an analysis of errors for our algorithm and compare it to state-of-the-art monitoring solutions, showing a superior performance where the allocated memory is less than $1MB$. In particular, we are able to detect more HH flows with lower false positive rate without increasing the per-packet processing time.

} % end of English abstract


\abstractHebrew{

מעקב אחר תעבורת רשת הוא אבן בניין חשובה עבור מערכות ניהול ואבטחה שונות. בדרך כלל, מספר הזרימות הפעילות במכשיר רשת, גדול בהרבה ממספר משאבי הניטור הזמינים. ובפועל, אין שום דרך מעשית לשמור מצב "לכל זרימה" קיימת שבמכשיר. מצב זה הוליד את ההתעניינות האחרונה באלגוריתמים של "סטרימינג" שבהם משתמשים במבני נתונים מורכבים לביצוע משימות ניטור ביעילות. עם זאת, לרוב, פתרונות אלה דורשים או פעולה מסובכת של "לכל חבילה", שאינן אפשריות במכשירי הרשת החומרתיים הנוכחים או במכשירי הרשת מבוססי התוכנה, או פעולה בעלות קבועה משוערכת, \textenglish{$O(1)$}, שמונעת מהתקן הרשת מלנתב את התעבורה בקצב הקו המקסימלי. במסמך זה אנו מתמודדים עם שלוש משימות ניטור שנחקרו בעבר ואנו מציגים עבורן אלגוריתמים יעילים, מעשיים ומוגבלים במשאבים.

הבעיה הראשונה היא זיהוי \textenglish{$k$} הזרמים (\textenglish{flows}) הכי גדולים הזורמים דרך התקן הרשת. עבור בעיה זו הצגנו גישה שונה מעבודות קודמות ובחנו את היכולת לבצע משימות ניטור באמצעות המונים המובנים היעילים הזמינים בהתקני הרשת הקיימים. אנו מראים כי על ידי יישום אלגוריתמי בקרה לא טריוויאליים המשנים את מסכות הסינון של מונים מובנים אלה במרווח זמן קבוע, ללא קשר לקצב הגעת החבילות, אנו יכולים לקבל מידע ניטור מדויק. אנו מספקים מחקר אנליטי של בעית זיהוי \textenglish{$k$} הזרמים הכי גדולים, ומראים באמצעות אמולציה נרחבת על פני מקטעי תעבורה אמיתית, כי ביצועי האלגוריתם שלנו הם לפחות כמו ביצועי אלגוריתמי ה"סטרימנג" הידועים ביותר מבלי להשתמש במבני נתונים מורכבים או לבצע פעולה "יקרה" לכל חבילה שמגיעה.

הבעיה השנייה היא בעיית הזרמים הכבדים ההיררכיים (\textenglish{HHH}), שבה צריך לזהות את קידומות רשתות ה-\textenglish{IP} הנפוצות ביותר מבחינה היררכית. עבור פתרון בעיה זו המשכנו את הגישה של הפתרון הקודם ל זיהוי \textenglish{$k$} הזרמים הכי גדולים, והצענו אלגוריתם "זמן קבוע" לאיתור ה-\textenglish{HHH} שאין לו דרישות התכנסות ומשיג תוצאות דומות לאלגורתמים הכי טובים שידועים כיום. בנוסף, התכונה הכי חשובה של האלגוריתם שלנו היא שהוא משתמש רק במונים המובנים היעילים הזמינים בהתקני הרשת הקיימים כיום, מה  שמאפשר את הרצתו על התקני רשת נפוצים שנחשבים להתקני מדף. מעבר לכך, סיפקנו מחקר אנליטי של הבעיה והראינו, באמצעות הדמיה על פני תעבורת רשת אמיתית, כי ביצועי האלגוריתם שלנו הן לפחות כמו האלגוריתמים הידועים ביותר מבלי לבצע פעולות יקרות לכל חבילה או לדרוש תקופות התכנסות כלשהיא.

הגישות שבהן נקטנו עבור פתרון שתי הבעיות הראשונות הינן דומות מבחינת התכלית. עיקר הפעולה מבוסס על חלוקה של זמן הניטור לפרקי זמן מחולקים סטטית, ואז לשלוט על הקצאת המונים המובנים לאחר סיום כל פרק זמן כזה. בכל פרק זמן כזה, מתרחשת הקצאה של המונים כדי למדוד חלקים מסויימים של מרחב כתובות הרשת הקיימות, לאחר סיום פרק הזמן וקבלת המדידיות מתבצעת חלוקה מחדש של המונים כדי לשקף מחדש את תחומי הרשת המעניינים את האלגוריתם כתלות בבעיה עצמה.

בבעית זיהוי \textenglish{$k$} הזרמים הכי גדולים הזורמים דרך התקן הרשת, האלגורתים פורס המונים בפרק הזמן הראשון ברמה המתאימה בהיררכה, כאשר הרמה המתאימה הינה הרמה הכי נמוכה שיש לאלגורתים מספיק מונים כדי לכסות את כולה. בסיום של כל פרק זמן כזה, האלגורתים מגלה את חצי הצמתים הכי גדולים ברמה הנוכחית ע"י השוואת ערכי המונים ומחליט על פריסת המונים ברמה הבאה בתור. ההחלטה על הרמה הבאה בתור מתבצעת לפי פירוק הצמתים הכי גדולים לשני צמתים בנים זרים בזרמים. האלגורתים ממצשיך הגישה זו עד הגעתו לרמה הכי נמוכה ואז מחליט על \textenglish{$k$} הזרמים הכי גדולים שהתגלו ומחזיר אותם. בנוסף, הצגנו שיפור לאלגורתים זה בצורה של הגדלת פרק הזמן הללו שמבמקום שימדדו רמה אחת, למדוד ביחד מספר רמות. בשיטה זו, אנו מבטיחים את יציבות הזרמים הכי גדולים כאשר עוברים בין הרמות מאחר שפרקי זמן המדידה הם יותר ארוכים. שיפור נוסף שהצגנו התבסס על מנגון תמצות של כותרי החבילות \textenglish{packet headers} באופן אקראי וחד חד ערכי, כדי למנוע את תופעת המיסוך. בתופעת המיסוך מתרחש מצב שבו אשכול (\textenglish{cluster}) של זרמים שאינם מבין הכי גדולים ממסכים זרם גדול, באופן שמונע מהאלגורתים להתרכז בו וגורם לאלגורתים לטעות. כאשר מבצעים את התמצות, אז מערבבים את הזרמים בתוך ההיררכיה באופן אחיד, כך שמפרקים אשכולות אלו. פירוק זה מונע את תופעת המיסוך מעצם אחידות התמצות.

בבעיית הזרמים הכבדים ההיררכיים, המשכנו את הגישה שמחלקת את זמן הניטור לפרקי זמן סטטיים, אולם על האלגורתים להתרכז לא בזרמים בכי גדולים אלא בזרמים שהצריכה שלהם הינה מעל סף מסויים. בפועל, האלגורתים התבסס על ההגדרה הרקורסיבית של הזרמים הכי כבדים ההיררכיים כדי לבנות שיטת "מלמטה למעלה" כדי לחשב אותם. בשיטה זו, האלגורתים מתרכז בכל רמה בזרמים הכי כבדים, ומפרק אותם לבנים זרים שלהם כפי שתואר בפסקה הקודמת. תהליך פירוק זה נמשך, עד שמגיעים לרמה הכי תחתונה. כאשר מגיעים לרמה הכי תחתונה, מתחיל תהליך של קיפול וחישוב הזרמים הכי כבדים ההיררכיים באותה רמה, ע"י הערכת התדירות המותנית (ה-\textenglish{Conditional Frequency}), של כל זרם שנבחר ברמה בהתבסס על הערך שנמדד עבורו ושל צאצאיו בתת ההיררכייה שאינם זרמים כבדים היררככיים בעצמם.

הבעיה האחרונה בה התמקדנו היא איתור הזרים הכבדים, \textenglish{HH}, שזורמים בהתקן רשת. בבעיה זו זרימה נחשבת לזרם כבד אם חלקה מהתעבורה הכוללת עולה על רף נתון. לבעיה זו אנו מציגים אלגוריתם מעשי של איתור זרמים כבדים הדורש כמות קבועה של זיכרון (שאינו קשור למספר הזרימות או למספר החבילות) ומבצע לכל היותר פעולת זמן קבוע, \textenglish{$O(1)$}, לחבילה כדי לאפשר בפעולה בקצב קו השידור המקסימלי. בנוסף, אנו מציגים ניתוח של שגיאות האלגוריתם ומשווים אותו לפתרונות ניטור מתקדמים אחרים, ומראים ביצועים מעולים כאשר הזיכרון המוקצה נמוך מ-\textenglish{$1MB$}. בפרט, אנו מסוגלים לזהות יותר זרמים הכי כבדיםעם אחוז גילוי כוזב יותר קטן מבלי להגדיל את זמן העיבוד לכל חבילה.

האלגורתים שלנו לבעיה זו נוקט בגישה שונה ממה שהשתמשנו בו עד כה. האלגורתים מבוסס על שני אלגורתמים קיימים ומשפר אותם. הראשון הינו אלגורתים "דגום והחזק" אשר דוגם מתוך זרם של חבילות בהסתברות מסויימת איזה זרמים למדוד באופן מדויק (מרגע דגימתם הראשונה), והשני הינו אלגורתים שנתון הערכת תדירות מבוססת על מונים משותפים אשר ערכיהם נבנו בצורה לצמצם למינימום את שגיאת ההערכה המקסימלית של התדירות. השילוב שלנו משתמש בשלושה מבני נתונים, הראשון שנקרא "מערך החשודים" אשר מחזיק את הזהות של הזרמים שנרא לאחרונה. השני שנקרא "מערך המועמדים" אשר מחזיק את הזרמים שמועמדים להיות הכי כבדים ועברו אליו מ"מערך החשודים". עבור כל מועמד, בנוסף לזהות שלו, אנו מחזיקים מונה אשר מצביע על המונה המשותף של אותו זרם במבנה הנתונים השלישי שנקרא "מערך המונים". כאשר חבילה של זרם מסויים נדגמת, היא מכניסה אותו ל"מערך החשודים". דגימה נוספת של אותו זרם מעבירה אותו ל"מערך המועמדים", ומשם כל דגימה מגדילה את המונה בהסתברות הופכית להפרש בין המונים. בשיטה זו, האלגורתים מחזיר את הזרמים שהמונה שלהם ב"מערך המונים" הינו מעל ערך הסף של הבעיה (שמחושב בהתאם לפרמטרים). מנגנון הדגימה הייחודי מאפשר לשמור על הפעולות קלות, כדי למנוע פגיעה בקצב הקו המקסימלי של התקן הרשת.
}
